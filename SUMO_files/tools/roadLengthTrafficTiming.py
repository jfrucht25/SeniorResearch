import argparse
import xml.etree.cElementTree as eleTree
"""
Create traffic light timings based off road lengths. The average speed is used to calculate how long
cars will take to travel the length of the road and to set timings.
"""

def average(in_list):
    return sum(in_list)/len(in_list)


parser = argparse.ArgumentParser(description="Create traffic light timings based on road lengths")
parser.add_argument("-n", "--network", help="input the filename of the network")
parser.add_argument("-a", "--additional-file", help="input the filename of the add file containing the traffic light data")
parser.add_argument("-o", "--output", help="input the name of the output file")
parser.add_argument("-c", "--cycle-length", help="Optional: desired length of light cycle", default=-1)
parser.add_argument("-m", "--multiplier", help="Optional: multiplier for traffic light (roughly the number of cars "
                                               "that should be able to travel the road completely)", default=1)
parser.add_argument("-y", "--yellow-length", help="Optional: length of a yellow cycle", default=3)
# TODO: add optional weight argument that is multiplied with the max time taken

args = parser.parse_args()
netTree = eleTree.parse(args.network)
netRoot = netTree.getroot()
edges = {}  # dictionary of id -> junction info,  lane length, and speed; use network to get
lights = {}  # dictionary of id -> list of [state, length of phases]
connections = {}  # dictionary of from edge -> to list of [edges, traffic lights, link indices]
for obj in netRoot:
    if obj.tag == "edge" and "function" not in obj.attrib.keys():
        edges[obj.attrib["id"]] = {"from": obj.attrib["from"], "to": obj.attrib["to"],
                                   "length": average([float(lane.attrib["length"]) for lane in obj]),
                                   "speed": average([float(lane.attrib["speed"]) for lane in obj]), "lights": obj}
    elif obj.tag == "tlLogic":
        lights[obj.attrib["id"]] = [{"duration": a.attrib["duration"], "state": a.attrib["state"]} for a in obj]
    elif obj.tag == "connection" and "tl" in obj.attrib:
        if obj.attrib["from"] in connections:
            connections[obj.attrib["from"]].append({"to": obj.attrib["to"], "tl": obj.attrib["tl"], "linkIndex": obj.attrib["linkIndex"]})
        else:
            connections[obj.attrib["from"]] = [{"to": obj.attrib["to"], "tl": obj.attrib["tl"], "linkIndex": obj.attrib["linkIndex"]}]

"""
For traffic lights that control a single intersection, the default indices generated generated by NETCONVERT are 
numbered in a clockwise pattern starting with 0 at 12 o'clock with right-turns ordered before straight connections 
and left turns. Pedestrian crossings are always assigned at the very end, also in a clockwise manner.
"""
for l in lights:
    # print(l)
    for phase in lights[l]:
        if "g" in phase["state"] or "G" in phase["state"]:
            # print(phase["state"])
            greens = [i for i, v in enumerate(phase["state"]) if v in "Gg"] # indices of green links, use them with connections to determine length of this phase
            green_connects = {traffic_id for traffic_id in connections for destination in connections[traffic_id]
                              if int(destination["linkIndex"]) in greens}
            # look at every green connect from edge, find the length and the speed, and estimate how long it would
            # take a car to travel that length(length/speed). Set duration to max time
            time_taken_greens = [edges[edge]["length"]/edges[edge]["speed"] for edge in green_connects]
            phase["duration"] = max(time_taken_greens)*float(args.multiplier)
            # print(phase["duration"])
        else:
            phase["duration"] = args.yellow_length

# TODO: If args.c is not -1, scale duration proportionally DONE
if int(args.cycle_length) != -1:
    for l in lights:
        sumPhases = sum(phase["duration"] for phase in lights[l])
        for phase in lights[l]:
            phase["duration"] = phase["duration"] / sumPhases * int(args.cycle_length)

# TODO: build new add file using timings decided from
add_tree = eleTree.parse(args.additional_file)
add_root = add_tree.getroot()
for light in add_root.findall("tlLogic"):
    light_id = light.attrib["id"]
    # print(light_id)
    for index, phase in enumerate(light):
        phase.attrib["duration"] = str(round(lights[light_id][index]["duration"],3))
"""
First element is additional, rest are traffic lights, also need traffic/pollution/noise dumps
"""
print(eleTree.tostring(add_root))
add_tree.write(args.output)





